# XOR Manipulation

XOR (`^`) is one of the most powerful operators in algorithmic problems due to its properties.

## Key Properties
1. **Commutative**: $a \oplus b = b \oplus a$
2. **Associative**: $a \oplus (b \oplus c) = (a \oplus b) \oplus c$
3. **Identity**: $a \oplus 0 = a$
4. **Self-Inverse**: $a \oplus a = 0$

## Problems

### 1. Single Number
**Problem**: Every element appears twice except for one. Find that single one.
**Intuition**: XOR all numbers. Pairs cancel out ($a \oplus a = 0$), leaving the unique number.

```python
def single_number(nums):
    res = 0
    for n in nums:
        res ^= n
    return res
```

### 2. Single Number III
**Problem**: Two numbers appear once, all others twice. Find the two numbers.
**Intuition**:
1. XOR all numbers to get `xor_all = a ^ b`.
2. Find any set bit in `xor_all` (this bit differs between `a` and `b`).
3. Partition numbers into two groups based on that bit. XORing each group reveals `a` and `b`.

```python
def single_number_iii(nums):
    xor_all = 0
    for n in nums:
        xor_all ^= n

    # Get rightmost set bit
    mask = xor_all & -xor_all

    a, b = 0, 0
    for n in nums:
        if n & mask:
            a ^= n
        else:
            b ^= n
    return [a, b]
```

### 3. Missing Number
**Problem**: Given array containing distinct numbers from `0, 1, ... n`, return the one missing from the array.
**Intuition**: XOR index and value. $Index: 0, 1, 2, 3...$ vs $Value: 0, 1, 3...$. Everything cancels except the missing one.

```python
def missing_number(nums):
    res = len(nums)
    for i, n in enumerate(nums):
        res ^= i ^ n
    return res
```

### 4. Find the Difference
**Problem**: String `t` is generated by shuffling `s` and adding one letter. Find that letter.
**Intuition**: Treat characters as integers (ASCII). XOR all chars in `s` and `t`. The result is the added char.

```python
def find_the_difference(s, t):
    code = 0
    for ch in s + t:
        code ^= ord(ch)
    return chr(code)
```
